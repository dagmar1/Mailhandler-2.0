<?php


/** 
 * Return a default content type if the user has not chosen a specific type on the settings page
 * In order of priority, return blog, story, page
 * This assumes that one of these basic types is in use on a site (page and story are active by default)
 * A user can choose other content types via the settings page as this exposes all available types
 */
function mailhandler_default_type() {

  // Get the current default setting, if defined
  $default_type = variable_get('mailhandler_default_type', NULL);

  // Find out what types are available
  $available_types = node_get_types('names');

  // Check the default type is still available (it could have been deleted)
  if ($default_type && array_key_exists($default_type, $available_types)) {
    return $default_type;
  }

  // If we get here then either no default is set, or the default type is no longer available

  // Search for the array key (the machine readable name) for blog, story and page basic types
  if (array_key_exists('blog', $available_types)) {
    $default_type = 'blog';
  }
  else if (array_key_exists('story', $available_types)) {
    $default_type = 'story';
  }
  else if (array_key_exists('page', $available_types)) {
    $default_type = 'page';
  }
  else {
    // If basic types not found then return the first item from the array as an alternative default
    $default_type = key($available_types);
  }

  return $default_type;

}

/**
 * Run message retrieval and node processing on a mailbox - is a wrapper around mailhandler_retrieve
 * 
 * Batch API smashes the stack, so this function is called twice when fetching
 * messages via batch in order to return the results from the batch.
 * 
 * @param $mailbox
 *   Array of mailbox configuration
 * @param $limit
 *   Int maximum number of messages to retrieve
 */
function mailhandler_node_process_mailbox($mailbox = FALSE, $limit = FALSE) {
  if ($messages = mailhandler_retrieve($mailbox, $mode, $limit)) {
    foreach ($messages as $message) {
      mailhandler_node_process_message($message['header'], $message['origbody'], $message['mailbox']);
    }
  }
}

// TODO: add arguments
function mailhandler_node_process_message($header, $origbody, $mailbox) {
  mailhandler_switch_user();
  // we must process before authenticating because the password may be in Commands
  $node = mailhandler_node_prepare_message($header, $origbody, $mailbox);

  // Authenticate the message
  if (!$node = mailhandler_mailhandler_authenticate('execute', $mailbox['authentication'], array($node, $header, $origbody, $mailbox))) {
    watchdog('mailhandler', 'Message failed authentication', array(), WATCHDOG_ERROR);
    return FALSE;
  }
  
  // Put $mimeparts on the node
  $node->mimeparts = $mimeparts;

  // we need to change the current user
  // this has to be done here to allow modules
  // to create users
  mailhandler_switch_user($node->uid);

  // modules may override node elements before submitting. they do so by returning the node.
  foreach (module_list() as $name) {
    if (module_hook($name, 'mailhandler')) {
      $function = $name .'_mailhandler';
      if (!($node = $function($node, $result, $i, $header, $mailbox))) {
        // Exit if a module has handled the submitted data.
        break;
      }
    }
  }

  if ($node) {
    if ($node->type == 'comment') {
      $nid = mailhandler_comment_submit($node, $header, $mailbox, $origbody);
      $type = 'comment';
    }
    else {
      $nid = mailhandler_node_submit($node, $header, $mailbox, $origbody);
      $type = 'node';
    }
  }
  
  // Invoke a second hook for modules to operate on the newly created/edited node/comment.
  foreach (module_list() as $name) {
    if (module_hook($name, 'mailhandler_post_save')) {
      $function = $name .'_mailhandler_post_save';
      // Pass in the $nid (which could be a $cid, depending on $node->type)
      $function($nid, $type);
    }
  }
  
  // switch back to original user
  mailhandler_switch_user();

  // Put something in the results array for the counter in the batch finished callback
  $context['results'][] = $mailbox['mail'];

  mailhandler_switch_user();
}

/**
 * Append default commands. Separate commands from body. Strip signature.
 * Return a node object.
 */
function mailhandler_node_prepare_message($header, $body, $mailbox) {

  // Initialise a node object
  $node = new stdClass();

  $node->pass = NULL;

  // Initialize parameters
  $sep = $mailbox['sigseparator'];

  // Copy any name/value pairs from In-Reply-To or References e-mail headers to $node. Useful for maintaining threading info.
  if (!empty($header->references)) {
    // we want the final element in references header, watching out for white space
    $threading = substr(strrchr($header->references, '<'), 0);
  }
  else if (!empty($header->in_reply_to)) {
    $threading = str_replace(strstr($header->in_reply_to, '>'), '>', $header->in_reply_to); // Some MUAs send more info in that header.
  }
  if (isset($threading) && $threading = rtrim(ltrim($threading, '<'), '>')) { //strip angle brackets
    if ($threading) $node->threading = $threading;
    parse_str($threading, $tmp);
    if ($tmp['host']) {
      $tmp['host'] = ltrim($tmp['host'], '@'); // strip unnecessary @ from 'host' element
    }
    foreach ($tmp as $key => $value) {
      $node->$key = $value;
    }
  }

  // Prepend the default commands for this mailbox
  if ($mailbox['commands']) {
    $body = trim($mailbox['commands']) ."\n". $body;
  }
  if ($commands = mailhandler_commands_parse($body)) {
    // The node type must be set first in order to properly initialize the node
    foreach ($commands['commands'] as $command) {
      if ($command[0] == 'type') {
        $node->type = $command[1];
      }
    }
  }
  // Set a default type if none provided
  if (!$node->type) $node->type = mailhandler_default_type();
  // Apply defaults to the $node object, and allow modules to add default values
  require_once($base_path . 'modules/node/node.pages.inc');
  node_object_prepare($node);
  // In order to fall back to the permission system for comment status, the status property must
  // be unset if type is comment.  It will get set by explicit commands, and if not, by 
  // comment_save itself.
  if($node->type == 'comment') {
    unset($node->status);
  }
  // Execute the commands
  if (!empty($commands['commands'])) {
    mailhandler_node_process_message_commands($node, $commands['commands']);
  }
  // Isolate the body from the commands and the sig
  $tmp = array_slice($commands['lines'], $commands['endcommands'], $commands['i'] - $commands['endcommands']);
  // flatten and assign the body to node object. note that filter() is called within node_save() [tested with blog post]
  $node->body = implode("\n", $tmp);

  if (empty($node->teaser)) $node->teaser = node_teaser($node->body);

  // decode encoded subject line
  $subjectarr = imap_mime_header_decode($header->subject);
  if (empty($subjectarr)) {
    $node->title = truncate_utf8(trim(decode_entities(strip_tags(check_markup($node->body)))), 29, TRUE);
  }
  else {
    for ($i = 0; $i < count($subjectarr); $i++) {
      if ($subjectarr[$i]->charset != 'default')
      $node->title .= drupal_convert_to_utf8($subjectarr[$i]->text, $subjectarr[$i]->charset);
      else
      $node->title .= $subjectarr[$i]->text;
    }
  }
  $node->date = $node->changed = format_date($header->udate, 'custom', 'Y-m-d H:i:s O');
  $node->format = $mailbox['format'];
  
  // If an nid command was supplied, and type is not 'comment', append the revision number
  if ($node->nid && $node->type != 'comment') {
    $vid = db_result(db_query('SELECT n.vid FROM {node} n WHERE n.nid = %d', $node->nid));
    if ($vid) {
      $node->revision = $node->vid = $vid;
    }
  }
  
  return $node;
}

/**
 * Create the comment.
 */
function mailhandler_comment_submit($node, $header, $mailbox, $origbody) {
  global $user;
  if (!$node->subject) $node->subject = $node->title;
  // When submitting comments, 'comment' means actualy the comment's body, and not the comments status for a node.
  // We need to reset the comment's body, so it doesn't colide with a default 'comment' command. 
  $node->comment = $node->body;
  // comment_save will not fall back to permission system if we set the status explicitly
  // See comment_save.  += will not overwrite an existing array property.
  if (property_exists($node, 'status')) {
    // In comment module, status of 1 means unpublished, status of 0 means published.
    $node->status == 1 ? $node->status = 0 : $node->status = 1;
  }
  // We want the comment to have the email time, not the current time
  $node->timestamp = $node->created;
  // comment_save gets an array
  $edit = (array)$node;

  // post the comment. if unable, send a failure email when so configured
  $cid = comment_save($edit);
  if (!$cid && $mailbox['replies']) {
    // $fromaddress really refers to the mail header which is authoritative for authentication
    list($fromaddress, $fromname) = mailhandler_get_fromaddress($header, $mailbox);
    $error_text = t('Sorry, your comment experienced an error and was not posted. Possible reasons are that you have insufficient permission to post comments or the node is no longer open for comments.');
    $params = array('body' => $origbody, 'error_messages' => array(), 'error_text' => $error_text, 'from' => $fromaddress, 'header' => $header, 'node' => $node);
    drupal_mail('mailhandler', 'mailhandler_error_comment', $fromaddress, user_preferred_language($user), $params);
    watchdog('mailhandler', 'Comment submission failure: %subject.', array('%subject' => $edit['subject']), WATCHDOG_ERROR);
  }
  
  return $cid;
}

/**
 * Create the node.
 */
function mailhandler_node_submit($node, $header, $mailbox, $origbody) {
  global $user;
  list($fromaddress, $fromname) = mailhandler_get_fromaddress($header, $mailbox);

  // Drupal 5.x & 6.x don't support multiple validations: each node_validate()
  // call will ADD error messages to previous ones, so if some validation error
  // occours in one message it will be reported in all messages after it.
  // Since there is no way to reset form errors, the only method to avoid this
  // problem is working with $_SESSION['messages'], used by form_set_error().
  // See http://drupal.org/node/271975 for more info.
  // Warning: with this method, if the same error message is reported for 2+ different
  // fields it will be detected only for the last one.
  if (!isset($_SESSION['messages'])) {
    $_SESSION['messages'] = array();
  }
  $saved_errors = isset($_SESSION['messages']['error']) ? $_SESSION['messages']['error'] : array();
  $_SESSION['messages']['error'] = array();
  node_validate($node);
  $error_messages = array();
  if (count($_SESSION['messages']['error'])) {
    $allerrors = form_get_errors();
    foreach ($_SESSION['messages']['error'] as $message) {
      $keys = array_keys($allerrors, $message);
      if (!$keys || !count($keys)) {
        // Not a validation error (but an error, i'll print it)
        $saved_errors[] = $message;
      } else {
        // This is a validation error, i take the last field with it (previous fields
        // should be about previous validations)
        $error_messages[$keys[count($keys) - 1]] = $message;
      }
    }
  }
  if (is_array($saved_errors) && count($saved_errors)) {
     $_SESSION['messages']['error'] = $saved_errors;
  }
  else {
    unset($_SESSION['messages']['error']);
  }

  if (!$error_messages) {
    // Prepare the node for save and allow modules make changes
    $node = node_submit($node);
    // Save the node
    if (!empty($node->nid)) {
      if (node_access('update', $node)) {
        node_save($node);
        watchdog('mailhandler', 'Updated %title by %from.', array('%title' => $node->title, '%from' => $fromaddress));
      }
      else {
        $error_text = t('The e-mail address !from may not update !type items.', array('!from' => $fromaddress, '!type' => $node->type));
        watchdog('mailhandler', 'Node submission failure: %from may not update %type items.', array('%from' => $fromaddress, '%type' => $node->type), WATCHDOG_WARNING);
      }
    }
    else {
      if (node_access('create', $node)) {
        node_save($node);
        watchdog('mailhandler', 'Added %title by %from.', array('%title' => $node->title, '%from' => $fromaddress));
      }
      else {
        $error_text = t('The e-mail address !from may not create !type items.', array('!from' => $fromaddress, '!type' => $node->type));
        watchdog('mailhandler', 'Node submission failure: %from may not create %type items.', array('%from' => $fromaddress, '%type' => $node->type), WATCHDOG_WARNING);
      }
    }
    // Return the node is successfully saved
    if (!isset($error_text)) {
      return $node;
    } 
  }
  else {
    $error_text = t('Your submission is invalid:');
    watchdog('mailhandler', 'Node submission failure: validation error.', array(), WATCHDOG_WARNING);
  }

  if (isset($error_text)) {
    if ($mailbox['replies']) {
      $params = array('body' => $origbody, 'error_messages' => $error_messages, 'error_text' => $error_text, 'from' => $fromaddress, 'header' => $header, 'node' => $node);
      drupal_mail('mailhandler', 'mailhandler_error_node', $fromaddress, user_preferred_language($user), $params);
    }
  }
  
  // return FALSE if the node was not successfully saved
  return FALSE;
}

/**
 * Accept a taxonomy term name and replace with a tid. this belongs in taxonomy.module.
 */
function mailhandler_term_map(&$term, $index = array(), $vid = FALSE) {
  // provide case insensitive and trimmed map so as to maximize likelihood of successful mapping
  if ($vid) {
    $and = 'AND vid =' . db_escape_string($vid);
  }
  $term = db_result(db_query("SELECT tid FROM {term_data} WHERE LOWER('%s') LIKE LOWER(name) $and", trim($term)));
}

function mailhandler_node_process_message_commands(&$node, $commands) {
  $vocabs = taxonomy_get_vocabularies($node->type);
  $node->taxonomy = array();
  foreach ($commands as $data) {
    // TODO: allow for nested arrays in commands ... Possibly trim() values after explode().
    // If needed, turn this command value into an array
    if (substr($data[1], 0, 1) == '[' && substr($data[1], -1, 1) == ']') {
      $data[1] = rtrim(ltrim($data[1], '['), ']'); //strip brackets
      $data[1] = explode(",", $data[1]);
      // allow for key value pairs
      foreach ($data[1] as $key => $value) {
        $data_tmp = explode(":", $value, 2);
        if (isset($data_tmp[1])) { // is it a key value pair?
          // remove old, add as key value pair
          unset($data[1][$key]);
          $data_tmp[0] = trim($data_tmp[0]);
          $data[1][$data_tmp[0]] = $data_tmp[1];
        }
      }
    }
    $data[0] = strtolower(str_replace(' ', '_', $data[0]));
    // if needed, map term names into IDs. this should move to taxonomy_mailhandler()
    if ($data[0] == 'taxonomy' && !is_numeric($data[1][0])) {
      array_walk($data[1], 'mailhandler_term_map');
      // Only add term if node type can use that term's vocab
      $term = taxonomy_get_term($data[1][0]);
      if (array_key_exists($term->vid, $vocabs)) {
        $node->taxonomy = array_merge($node->taxonomy, $data[1]);
      }
      unset($data[0]);
    }
    else if (substr($data[0], 0, 9) == 'taxonomy[' && substr($data[0], -1, 1) == ']'){
      // make sure a valid vid is passed in:
      $vid = substr($data[0], 9, -1);
      $vocabulary = taxonomy_vocabulary_load($vid);
      // if the vocabulary is not activated for that node type, unset $data[0], so the command will be ommited from $node
      // TODO: add an error message
      if (!in_array($node->type, $vocabulary->nodes)) {
        unset($data[0]);
      }
      else if (!$vocabulary->tags) {
        array_walk($data[1], 'mailhandler_term_map', $vid);
        $node->taxonomy = array_merge($node->taxonomy, $data[1]);
        unset($data[0]);
      }
      else if ($vocabulary->tags) {
        // for freetagging vocabularies, we just pass the list of terms
        $node->taxonomy['tags'][$vid] = implode(',', $data[1]);
        unset($data[0]); // unset, so it won't be included when populating the node object
      }
    }
    if (!empty($data[0])) {
      $node->$data[0] = $data[1];
    }
  }
}
